wrap!(pub fn IsArray(cx: *mut JSContext, obj: HandleObject, isArray: *mut bool) -> bool);
wrap!(pub fn IsArray1(cx: *mut JSContext, obj: HandleObject, answer: *mut IsArrayAnswer) -> bool);
wrap!(pub fn Unbox(cx: *mut JSContext, obj: HandleObject, vp: MutableHandleValue) -> bool);
wrap!(pub fn JS_ReadStructuredClone(cx: *mut JSContext, data: *mut u64, nbytes: usize, version: u32, vp: MutableHandleValue, optionalCallbacks: *const JSStructuredCloneCallbacks, closure: *mut ::std::os::raw::c_void) -> bool);
wrap!(pub fn JS_WriteStructuredClone(cx: *mut JSContext, v: HandleValue, datap: *mut *mut u64, nbytesp: *mut usize, optionalCallbacks: *const JSStructuredCloneCallbacks, closure: *mut ::std::os::raw::c_void, transferable: HandleValue) -> bool);
wrap!(pub fn JS_StructuredClone(cx: *mut JSContext, v: HandleValue, vp: MutableHandleValue, optionalCallbacks: *const JSStructuredCloneCallbacks, closure: *mut ::std::os::raw::c_void) -> bool);
wrap!(pub fn JS_ReadTypedArray(r: *mut JSStructuredCloneReader, vp: MutableHandleValue) -> bool);
wrap!(pub fn JS_WriteString(w: *mut JSStructuredCloneWriter, str: HandleString) -> bool);
wrap!(pub fn JS_WriteTypedArray(w: *mut JSStructuredCloneWriter, v: HandleValue) -> bool);
wrap!(pub fn JS_ObjectNotWritten(w: *mut JSStructuredCloneWriter, obj: HandleObject) -> bool);
wrap!(pub fn JS_ValueToObject(cx: *mut JSContext, v: HandleValue, objp: MutableHandleObject) -> bool);
wrap!(pub fn JS_ValueToFunction(cx: *mut JSContext, v: HandleValue) -> *mut JSFunction);
wrap!(pub fn JS_ValueToConstructor(cx: *mut JSContext, v: HandleValue) -> *mut JSFunction);
wrap!(pub fn JS_ValueToSource(cx: *mut JSContext, v: Handle<Value>) -> *mut JSString);
wrap!(pub fn JS_TypeOfValue(cx: *mut JSContext, v: Handle<Value>) -> JSType);
wrap!(pub fn JS_StrictlyEqual(cx: *mut JSContext, v1: Handle<Value>, v2: Handle<Value>, equal: *mut bool) -> bool);
wrap!(pub fn JS_LooselyEqual(cx: *mut JSContext, v1: Handle<Value>, v2: Handle<Value>, equal: *mut bool) -> bool);
wrap!(pub fn JS_SameValue(cx: *mut JSContext, v1: Handle<Value>, v2: Handle<Value>, same: *mut bool) -> bool);
wrap!(pub fn JS_WrapObject(cx: *mut JSContext, objp: MutableHandleObject) -> bool);
wrap!(pub fn JS_WrapValue(cx: *mut JSContext, vp: MutableHandleValue) -> bool);
wrap!(pub fn JS_TransplantObject(cx: *mut JSContext, origobj: HandleObject, target: HandleObject) -> *mut JSObject);
wrap!(pub fn JS_RefreshCrossCompartmentWrappers(cx: *mut JSContext, obj: HandleObject) -> bool);
wrap!(pub fn JS_InitStandardClasses(cx: *mut JSContext, obj: HandleObject) -> bool);
wrap!(pub fn JS_ResolveStandardClass(cx: *mut JSContext, obj: HandleObject, id: HandleId, resolved: *mut bool) -> bool);
wrap!(pub fn JS_EnumerateStandardClasses(cx: *mut JSContext, obj: HandleObject) -> bool);
wrap!(pub fn JS_GetClassObject(cx: *mut JSContext, key: JSProtoKey, objp: MutableHandleObject) -> bool);
wrap!(pub fn JS_GetClassPrototype(cx: *mut JSContext, key: JSProtoKey, objp: MutableHandleObject) -> bool);
wrap!(pub fn ProtoKeyToId(cx: *mut JSContext, key: JSProtoKey, idp: MutableHandleId));
wrap!(pub fn JS_IdToProtoKey(cx: *mut JSContext, id: HandleId) -> JSProtoKey);
wrap!(pub fn JS_GetFunctionPrototype(cx: *mut JSContext, forObj: HandleObject) -> *mut JSObject);
wrap!(pub fn JS_GetObjectPrototype(cx: *mut JSContext, forObj: HandleObject) -> *mut JSObject);
wrap!(pub fn JS_GetArrayPrototype(cx: *mut JSContext, forObj: HandleObject) -> *mut JSObject);
wrap!(pub fn JS_InitReflectParse(cx: *mut JSContext, global: HandleObject) -> bool);
wrap!(pub fn JS_DefineProfilingFunctions(cx: *mut JSContext, obj: HandleObject) -> bool);
wrap!(pub fn JS_DefineDebuggerObject(cx: *mut JSContext, obj: HandleObject) -> bool);
wrap!(pub fn JS_ValueToId(cx: *mut JSContext, v: HandleValue, idp: MutableHandleId) -> bool);
wrap!(pub fn JS_StringToId(cx: *mut JSContext, s: HandleString, idp: MutableHandleId) -> bool);
wrap!(pub fn JS_IdToValue(cx: *mut JSContext, id: jsid, vp: MutableHandle<Value>) -> bool);
wrap!(pub fn ToPrimitive(cx: *mut JSContext, obj: HandleObject, hint: JSType, vp: MutableHandleValue) -> bool);
wrap!(pub fn JS_PropertyStub(cx: *mut JSContext, obj: HandleObject, id: HandleId, vp: MutableHandleValue) -> bool);
wrap!(pub fn JS_StrictPropertyStub(cx: *mut JSContext, obj: HandleObject, id: HandleId, vp: MutableHandleValue, result: *mut ObjectOpResult) -> bool);
wrap!(pub fn JS_InitClass(cx: *mut JSContext, obj: HandleObject, parent_proto: HandleObject, clasp: *const JSClass, constructor: JSNative, nargs: ::std::os::raw::c_uint, ps: *const JSPropertySpec, fs: *const JSFunctionSpec, static_ps: *const JSPropertySpec, static_fs: *const JSFunctionSpec) -> *mut JSObject);
wrap!(pub fn JS_LinkConstructorAndPrototype(cx: *mut JSContext, ctor: HandleObject, proto: HandleObject) -> bool);
wrap!(pub fn JS_InstanceOf(cx: *mut JSContext, obj: HandleObject, clasp: *const JSClass, args: *mut CallArgs) -> bool);
wrap!(pub fn JS_HasInstance(cx: *mut JSContext, obj: HandleObject, v: Handle<Value>, bp: *mut bool) -> bool);
wrap!(pub fn JS_GetInstancePrivate(cx: *mut JSContext, obj: HandleObject, clasp: *const JSClass, args: *mut CallArgs) -> *mut ::std::os::raw::c_void);
wrap!(pub fn JS_GetConstructor(cx: *mut JSContext, proto: HandleObject) -> *mut JSObject);
wrap!(pub fn JS_FireOnNewGlobalObject(cx: *mut JSContext, global: HandleObject));
wrap!(pub fn JS_NewObjectWithGivenProto(cx: *mut JSContext, clasp: *const JSClass, proto: HandleObject) -> *mut JSObject);
wrap!(pub fn JS_DeepFreezeObject(cx: *mut JSContext, obj: HandleObject) -> bool);
wrap!(pub fn JS_FreezeObject(cx: *mut JSContext, obj: HandleObject) -> bool);
wrap!(pub fn ObjectToCompletePropertyDescriptor(cx: *mut JSContext, obj: HandleObject, descriptor: HandleValue, desc: MutableHandle<PropertyDescriptor>) -> bool);
wrap!(pub fn FromPropertyDescriptor(cx: *mut JSContext, desc: Handle<PropertyDescriptor>, vp: MutableHandleValue) -> bool);
wrap!(pub fn JS_GetPrototype(cx: *mut JSContext, obj: HandleObject, result: MutableHandleObject) -> bool);
wrap!(pub fn JS_GetPrototypeIfOrdinary(cx: *mut JSContext, obj: HandleObject, isOrdinary: *mut bool, result: MutableHandleObject) -> bool);
wrap!(pub fn JS_SetPrototype(cx: *mut JSContext, obj: HandleObject, proto: HandleObject) -> bool);
wrap!(pub fn JS_IsExtensible(cx: *mut JSContext, obj: HandleObject, extensible: *mut bool) -> bool);
wrap!(pub fn JS_PreventExtensions(cx: *mut JSContext, obj: HandleObject, result: *mut ObjectOpResult) -> bool);
wrap!(pub fn JS_SetImmutablePrototype(cx: *mut JSContext, obj: HandleObject, succeeded: *mut bool) -> bool);
wrap!(pub fn JS_GetOwnPropertyDescriptorById(cx: *mut JSContext, obj: HandleObject, id: HandleId, desc: MutableHandle<PropertyDescriptor>) -> bool);
wrap!(pub fn JS_GetOwnPropertyDescriptor(cx: *mut JSContext, obj: HandleObject, name: *const ::std::os::raw::c_char, desc: MutableHandle<PropertyDescriptor>) -> bool);
wrap!(pub fn JS_GetOwnUCPropertyDescriptor(cx: *mut JSContext, obj: HandleObject, name: *const ::std::os::raw::c_ushort, desc: MutableHandle<PropertyDescriptor>) -> bool);
wrap!(pub fn JS_GetPropertyDescriptorById(cx: *mut JSContext, obj: HandleObject, id: HandleId, desc: MutableHandle<PropertyDescriptor>) -> bool);
wrap!(pub fn JS_GetPropertyDescriptor(cx: *mut JSContext, obj: HandleObject, name: *const ::std::os::raw::c_char, desc: MutableHandle<PropertyDescriptor>) -> bool);
wrap!(pub fn JS_DefinePropertyById(cx: *mut JSContext, obj: HandleObject, id: HandleId, desc: Handle<PropertyDescriptor>, result: *mut ObjectOpResult) -> bool);
wrap!(pub fn JS_DefinePropertyById1(cx: *mut JSContext, obj: HandleObject, id: HandleId, desc: Handle<PropertyDescriptor>) -> bool);
wrap!(pub fn JS_DefinePropertyById2(cx: *mut JSContext, obj: HandleObject, id: HandleId, value: HandleValue, attrs: ::std::os::raw::c_uint, getter: JSNative, setter: JSNative) -> bool);
wrap!(pub fn JS_DefinePropertyById3(cx: *mut JSContext, obj: HandleObject, id: HandleId, value: HandleObject, attrs: ::std::os::raw::c_uint, getter: JSNative, setter: JSNative) -> bool);
wrap!(pub fn JS_DefinePropertyById4(cx: *mut JSContext, obj: HandleObject, id: HandleId, value: HandleString, attrs: ::std::os::raw::c_uint, getter: JSNative, setter: JSNative) -> bool);
wrap!(pub fn JS_DefinePropertyById5(cx: *mut JSContext, obj: HandleObject, id: HandleId, value: i32, attrs: ::std::os::raw::c_uint, getter: JSNative, setter: JSNative) -> bool);
wrap!(pub fn JS_DefinePropertyById6(cx: *mut JSContext, obj: HandleObject, id: HandleId, value: u32, attrs: ::std::os::raw::c_uint, getter: JSNative, setter: JSNative) -> bool);
wrap!(pub fn JS_DefinePropertyById7(cx: *mut JSContext, obj: HandleObject, id: HandleId, value: f64, attrs: ::std::os::raw::c_uint, getter: JSNative, setter: JSNative) -> bool);
wrap!(pub fn JS_DefineProperty(cx: *mut JSContext, obj: HandleObject, name: *const ::std::os::raw::c_char, value: HandleValue, attrs: ::std::os::raw::c_uint, getter: JSNative, setter: JSNative) -> bool);
wrap!(pub fn JS_DefineProperty1(cx: *mut JSContext, obj: HandleObject, name: *const ::std::os::raw::c_char, value: HandleObject, attrs: ::std::os::raw::c_uint, getter: JSNative, setter: JSNative) -> bool);
wrap!(pub fn JS_DefineProperty2(cx: *mut JSContext, obj: HandleObject, name: *const ::std::os::raw::c_char, value: HandleString, attrs: ::std::os::raw::c_uint, getter: JSNative, setter: JSNative) -> bool);
wrap!(pub fn JS_DefineProperty3(cx: *mut JSContext, obj: HandleObject, name: *const ::std::os::raw::c_char, value: i32, attrs: ::std::os::raw::c_uint, getter: JSNative, setter: JSNative) -> bool);
wrap!(pub fn JS_DefineProperty4(cx: *mut JSContext, obj: HandleObject, name: *const ::std::os::raw::c_char, value: u32, attrs: ::std::os::raw::c_uint, getter: JSNative, setter: JSNative) -> bool);
wrap!(pub fn JS_DefineProperty5(cx: *mut JSContext, obj: HandleObject, name: *const ::std::os::raw::c_char, value: f64, attrs: ::std::os::raw::c_uint, getter: JSNative, setter: JSNative) -> bool);
wrap!(pub fn JS_DefineUCProperty(cx: *mut JSContext, obj: HandleObject, name: *const ::std::os::raw::c_ushort, namelen: usize, desc: Handle<PropertyDescriptor>, result: *mut ObjectOpResult) -> bool);
wrap!(pub fn JS_DefineUCProperty1(cx: *mut JSContext, obj: HandleObject, name: *const ::std::os::raw::c_ushort, namelen: usize, desc: Handle<PropertyDescriptor>) -> bool);
wrap!(pub fn JS_DefineUCProperty2(cx: *mut JSContext, obj: HandleObject, name: *const ::std::os::raw::c_ushort, namelen: usize, value: HandleValue, attrs: ::std::os::raw::c_uint, getter: JSNative, setter: JSNative) -> bool);
wrap!(pub fn JS_DefineUCProperty3(cx: *mut JSContext, obj: HandleObject, name: *const ::std::os::raw::c_ushort, namelen: usize, value: HandleObject, attrs: ::std::os::raw::c_uint, getter: JSNative, setter: JSNative) -> bool);
wrap!(pub fn JS_DefineUCProperty4(cx: *mut JSContext, obj: HandleObject, name: *const ::std::os::raw::c_ushort, namelen: usize, value: HandleString, attrs: ::std::os::raw::c_uint, getter: JSNative, setter: JSNative) -> bool);
wrap!(pub fn JS_DefineUCProperty5(cx: *mut JSContext, obj: HandleObject, name: *const ::std::os::raw::c_ushort, namelen: usize, value: i32, attrs: ::std::os::raw::c_uint, getter: JSNative, setter: JSNative) -> bool);
wrap!(pub fn JS_DefineUCProperty6(cx: *mut JSContext, obj: HandleObject, name: *const ::std::os::raw::c_ushort, namelen: usize, value: u32, attrs: ::std::os::raw::c_uint, getter: JSNative, setter: JSNative) -> bool);
wrap!(pub fn JS_DefineUCProperty7(cx: *mut JSContext, obj: HandleObject, name: *const ::std::os::raw::c_ushort, namelen: usize, value: f64, attrs: ::std::os::raw::c_uint, getter: JSNative, setter: JSNative) -> bool);
wrap!(pub fn JS_DefineElement(cx: *mut JSContext, obj: HandleObject, index: u32, value: HandleValue, attrs: ::std::os::raw::c_uint, getter: JSNative, setter: JSNative) -> bool);
wrap!(pub fn JS_DefineElement1(cx: *mut JSContext, obj: HandleObject, index: u32, value: HandleObject, attrs: ::std::os::raw::c_uint, getter: JSNative, setter: JSNative) -> bool);
wrap!(pub fn JS_DefineElement2(cx: *mut JSContext, obj: HandleObject, index: u32, value: HandleString, attrs: ::std::os::raw::c_uint, getter: JSNative, setter: JSNative) -> bool);
wrap!(pub fn JS_DefineElement3(cx: *mut JSContext, obj: HandleObject, index: u32, value: i32, attrs: ::std::os::raw::c_uint, getter: JSNative, setter: JSNative) -> bool);
wrap!(pub fn JS_DefineElement4(cx: *mut JSContext, obj: HandleObject, index: u32, value: u32, attrs: ::std::os::raw::c_uint, getter: JSNative, setter: JSNative) -> bool);
wrap!(pub fn JS_DefineElement5(cx: *mut JSContext, obj: HandleObject, index: u32, value: f64, attrs: ::std::os::raw::c_uint, getter: JSNative, setter: JSNative) -> bool);
wrap!(pub fn JS_HasPropertyById(cx: *mut JSContext, obj: HandleObject, id: HandleId, foundp: *mut bool) -> bool);
wrap!(pub fn JS_HasProperty(cx: *mut JSContext, obj: HandleObject, name: *const ::std::os::raw::c_char, foundp: *mut bool) -> bool);
wrap!(pub fn JS_HasUCProperty(cx: *mut JSContext, obj: HandleObject, name: *const ::std::os::raw::c_ushort, namelen: usize, vp: *mut bool) -> bool);
wrap!(pub fn JS_HasElement(cx: *mut JSContext, obj: HandleObject, index: u32, foundp: *mut bool) -> bool);
wrap!(pub fn JS_HasOwnPropertyById(cx: *mut JSContext, obj: HandleObject, id: HandleId, foundp: *mut bool) -> bool);
wrap!(pub fn JS_HasOwnProperty(cx: *mut JSContext, obj: HandleObject, name: *const ::std::os::raw::c_char, foundp: *mut bool) -> bool);
wrap!(pub fn JS_ForwardGetPropertyTo(cx: *mut JSContext, obj: HandleObject, id: HandleId, receiver: HandleValue, vp: MutableHandleValue) -> bool);
wrap!(pub fn JS_ForwardGetElementTo(cx: *mut JSContext, obj: HandleObject, index: u32, receiver: HandleObject, vp: MutableHandleValue) -> bool);
wrap!(pub fn JS_GetPropertyById(cx: *mut JSContext, obj: HandleObject, id: HandleId, vp: MutableHandleValue) -> bool);
wrap!(pub fn JS_GetProperty(cx: *mut JSContext, obj: HandleObject, name: *const ::std::os::raw::c_char, vp: MutableHandleValue) -> bool);
wrap!(pub fn JS_GetUCProperty(cx: *mut JSContext, obj: HandleObject, name: *const ::std::os::raw::c_ushort, namelen: usize, vp: MutableHandleValue) -> bool);
wrap!(pub fn JS_GetElement(cx: *mut JSContext, obj: HandleObject, index: u32, vp: MutableHandleValue) -> bool);
wrap!(pub fn JS_ForwardSetPropertyTo(cx: *mut JSContext, obj: HandleObject, id: HandleId, v: HandleValue, receiver: HandleValue, result: *mut ObjectOpResult) -> bool);
wrap!(pub fn JS_SetPropertyById(cx: *mut JSContext, obj: HandleObject, id: HandleId, v: HandleValue) -> bool);
wrap!(pub fn JS_SetProperty(cx: *mut JSContext, obj: HandleObject, name: *const ::std::os::raw::c_char, v: HandleValue) -> bool);
wrap!(pub fn JS_SetUCProperty(cx: *mut JSContext, obj: HandleObject, name: *const ::std::os::raw::c_ushort, namelen: usize, v: HandleValue) -> bool);
wrap!(pub fn JS_SetElement(cx: *mut JSContext, obj: HandleObject, index: u32, v: HandleValue) -> bool);
wrap!(pub fn JS_SetElement1(cx: *mut JSContext, obj: HandleObject, index: u32, v: HandleObject) -> bool);
wrap!(pub fn JS_SetElement2(cx: *mut JSContext, obj: HandleObject, index: u32, v: HandleString) -> bool);
wrap!(pub fn JS_SetElement3(cx: *mut JSContext, obj: HandleObject, index: u32, v: i32) -> bool);
wrap!(pub fn JS_SetElement4(cx: *mut JSContext, obj: HandleObject, index: u32, v: u32) -> bool);
wrap!(pub fn JS_SetElement5(cx: *mut JSContext, obj: HandleObject, index: u32, v: f64) -> bool);
wrap!(pub fn JS_DeletePropertyById(cx: *mut JSContext, obj: HandleObject, id: HandleId, result: *mut ObjectOpResult) -> bool);
wrap!(pub fn JS_DeleteProperty(cx: *mut JSContext, obj: HandleObject, name: *const ::std::os::raw::c_char, result: *mut ObjectOpResult) -> bool);
wrap!(pub fn JS_DeleteUCProperty(cx: *mut JSContext, obj: HandleObject, name: *const ::std::os::raw::c_ushort, namelen: usize, result: *mut ObjectOpResult) -> bool);
wrap!(pub fn JS_DeleteElement(cx: *mut JSContext, obj: HandleObject, index: u32, result: *mut ObjectOpResult) -> bool);
wrap!(pub fn JS_DeletePropertyById1(cx: *mut JSContext, obj: HandleObject, id: jsid) -> bool);
wrap!(pub fn JS_DeleteProperty1(cx: *mut JSContext, obj: HandleObject, name: *const ::std::os::raw::c_char) -> bool);
wrap!(pub fn JS_DeleteElement1(cx: *mut JSContext, obj: HandleObject, index: u32) -> bool);
wrap!(pub fn JS_CallFunctionValue(cx: *mut JSContext, obj: HandleObject, fval: HandleValue, args: *const HandleValueArray, rval: MutableHandleValue) -> bool);
wrap!(pub fn JS_CallFunction(cx: *mut JSContext, obj: HandleObject, fun: HandleFunction, args: *const HandleValueArray, rval: MutableHandleValue) -> bool);
wrap!(pub fn JS_CallFunctionName(cx: *mut JSContext, obj: HandleObject, name: *const ::std::os::raw::c_char, args: *const HandleValueArray, rval: MutableHandleValue) -> bool);
wrap!(pub fn Call(cx: *mut JSContext, thisv: HandleValue, fun: HandleValue, args: *const HandleValueArray, rval: MutableHandleValue) -> bool);
wrap!(pub fn Construct(cx: *mut JSContext, fun: HandleValue, newTarget: HandleObject, args: *const HandleValueArray, objp: MutableHandleObject) -> bool);
wrap!(pub fn Construct1(cx: *mut JSContext, fun: HandleValue, args: *const HandleValueArray, objp: MutableHandleObject) -> bool);
wrap!(pub fn JS_New(cx: *mut JSContext, ctor: HandleObject, args: *const HandleValueArray) -> *mut JSObject);
wrap!(pub fn JS_DefineObject(cx: *mut JSContext, obj: HandleObject, name: *const ::std::os::raw::c_char, clasp: *const JSClass, attrs: ::std::os::raw::c_uint) -> *mut JSObject);
wrap!(pub fn JS_DefineConstDoubles(cx: *mut JSContext, obj: HandleObject, cds: *const JSConstDoubleSpec) -> bool);
wrap!(pub fn JS_DefineConstIntegers(cx: *mut JSContext, obj: HandleObject, cis: *const JSConstIntegerSpec) -> bool);
wrap!(pub fn JS_DefineProperties(cx: *mut JSContext, obj: HandleObject, ps: *const JSPropertySpec) -> bool);
wrap!(pub fn JS_AlreadyHasOwnPropertyById(cx: *mut JSContext, obj: HandleObject, id: HandleId, foundp: *mut bool) -> bool);
wrap!(pub fn JS_AlreadyHasOwnProperty(cx: *mut JSContext, obj: HandleObject, name: *const ::std::os::raw::c_char, foundp: *mut bool) -> bool);
wrap!(pub fn JS_AlreadyHasOwnUCProperty(cx: *mut JSContext, obj: HandleObject, name: *const ::std::os::raw::c_ushort, namelen: usize, foundp: *mut bool) -> bool);
wrap!(pub fn JS_AlreadyHasOwnElement(cx: *mut JSContext, obj: HandleObject, index: u32, foundp: *mut bool) -> bool);
wrap!(pub fn JS_NewArrayObject(cx: *mut JSContext, contents: *const HandleValueArray) -> *mut JSObject);
wrap!(pub fn JS_IsArrayObject(cx: *mut JSContext, value: HandleValue, isArray: *mut bool) -> bool);
wrap!(pub fn JS_IsArrayObject1(cx: *mut JSContext, obj: HandleObject, isArray: *mut bool) -> bool);
wrap!(pub fn JS_GetArrayLength(cx: *mut JSContext, obj: HandleObject, lengthp: *mut u32) -> bool);
wrap!(pub fn JS_SetArrayLength(cx: *mut JSContext, obj: HandleObject, length: u32) -> bool);
wrap!(pub fn JS_StealArrayBufferContents(cx: *mut JSContext, obj: HandleObject) -> *mut ::std::os::raw::c_void);
wrap!(pub fn GetSelfHostedFunction(cx: *mut JSContext, selfHostedName: *const ::std::os::raw::c_char, id: HandleId, nargs: ::std::os::raw::c_uint) -> *mut JSFunction);
wrap!(pub fn NewFunctionFromSpec(cx: *mut JSContext, fs: *const JSFunctionSpec, id: HandleId) -> *mut JSFunction);
wrap!(pub fn JS_DefineFunctions(cx: *mut JSContext, obj: HandleObject, fs: *const JSFunctionSpec) -> bool);
wrap!(pub fn JS_DefineFunction(cx: *mut JSContext, obj: HandleObject, name: *const ::std::os::raw::c_char, call: JSNative, nargs: ::std::os::raw::c_uint, attrs: ::std::os::raw::c_uint) -> *mut JSFunction);
wrap!(pub fn JS_DefineUCFunction(cx: *mut JSContext, obj: HandleObject, name: *const ::std::os::raw::c_ushort, namelen: usize, call: JSNative, nargs: ::std::os::raw::c_uint, attrs: ::std::os::raw::c_uint) -> *mut JSFunction);
wrap!(pub fn JS_DefineFunctionById(cx: *mut JSContext, obj: HandleObject, id: Handle<jsid>, call: JSNative, nargs: ::std::os::raw::c_uint, attrs: ::std::os::raw::c_uint) -> *mut JSFunction);
wrap!(pub fn CloneFunctionObject(cx: *mut JSContext, funobj: HandleObject) -> *mut JSObject);
wrap!(pub fn CloneFunctionObject1(cx: *mut JSContext, funobj: HandleObject, scopeChain: *mut AutoObjectVector) -> *mut JSObject);
wrap!(pub fn JS_BufferIsCompilableUnit(cx: *mut JSContext, obj: HandleObject, utf8: *const ::std::os::raw::c_char, length: usize) -> bool);
wrap!(pub fn JS_CompileScript(cx: *mut JSContext, ascii: *const ::std::os::raw::c_char, length: usize, options: *const CompileOptions, script: MutableHandleScript) -> bool);
wrap!(pub fn JS_CompileUCScript(cx: *mut JSContext, chars: *const ::std::os::raw::c_ushort, length: usize, options: *const CompileOptions, script: MutableHandleScript) -> bool);
wrap!(pub fn JS_GetFunctionScript(cx: *mut JSContext, fun: HandleFunction) -> *mut JSScript);
wrap!(pub fn Compile(cx: *mut JSContext, options: *const ReadOnlyCompileOptions, srcBuf: *mut SourceBufferHolder, script: MutableHandleScript) -> bool);
wrap!(pub fn Compile1(cx: *mut JSContext, options: *const ReadOnlyCompileOptions, bytes: *const ::std::os::raw::c_char, length: usize, script: MutableHandleScript) -> bool);
wrap!(pub fn Compile2(cx: *mut JSContext, options: *const ReadOnlyCompileOptions, chars: *const ::std::os::raw::c_ushort, length: usize, script: MutableHandleScript) -> bool);
wrap!(pub fn Compile3(cx: *mut JSContext, options: *const ReadOnlyCompileOptions, file: *mut FILE, script: MutableHandleScript) -> bool);
wrap!(pub fn Compile4(cx: *mut JSContext, options: *const ReadOnlyCompileOptions, filename: *const ::std::os::raw::c_char, script: MutableHandleScript) -> bool);
wrap!(pub fn CompileForNonSyntacticScope(cx: *mut JSContext, options: *const ReadOnlyCompileOptions, srcBuf: *mut SourceBufferHolder, script: MutableHandleScript) -> bool);
wrap!(pub fn CompileForNonSyntacticScope1(cx: *mut JSContext, options: *const ReadOnlyCompileOptions, bytes: *const ::std::os::raw::c_char, length: usize, script: MutableHandleScript) -> bool);
wrap!(pub fn CompileForNonSyntacticScope2(cx: *mut JSContext, options: *const ReadOnlyCompileOptions, chars: *const ::std::os::raw::c_ushort, length: usize, script: MutableHandleScript) -> bool);
wrap!(pub fn CompileForNonSyntacticScope3(cx: *mut JSContext, options: *const ReadOnlyCompileOptions, file: *mut FILE, script: MutableHandleScript) -> bool);
wrap!(pub fn CompileForNonSyntacticScope4(cx: *mut JSContext, options: *const ReadOnlyCompileOptions, filename: *const ::std::os::raw::c_char, script: MutableHandleScript) -> bool);
wrap!(pub fn CompileFunction(cx: *mut JSContext, scopeChain: *mut AutoObjectVector, options: *const ReadOnlyCompileOptions, name: *const ::std::os::raw::c_char, nargs: ::std::os::raw::c_uint, argnames: *const *const ::std::os::raw::c_char, chars: *const ::std::os::raw::c_ushort, length: usize, fun: MutableHandleFunction) -> bool);
wrap!(pub fn CompileFunction1(cx: *mut JSContext, scopeChain: *mut AutoObjectVector, options: *const ReadOnlyCompileOptions, name: *const ::std::os::raw::c_char, nargs: ::std::os::raw::c_uint, argnames: *const *const ::std::os::raw::c_char, srcBuf: *mut SourceBufferHolder, fun: MutableHandleFunction) -> bool);
wrap!(pub fn CompileFunction2(cx: *mut JSContext, scopeChain: *mut AutoObjectVector, options: *const ReadOnlyCompileOptions, name: *const ::std::os::raw::c_char, nargs: ::std::os::raw::c_uint, argnames: *const *const ::std::os::raw::c_char, bytes: *const ::std::os::raw::c_char, length: usize, fun: MutableHandleFunction) -> bool);
wrap!(pub fn JS_DecompileScript(cx: *mut JSContext, script: Handle<*mut JSScript>, name: *const ::std::os::raw::c_char, indent: ::std::os::raw::c_uint) -> *mut JSString);
wrap!(pub fn JS_DecompileFunction(cx: *mut JSContext, fun: Handle<*mut JSFunction>, indent: ::std::os::raw::c_uint) -> *mut JSString);
wrap!(pub fn JS_ExecuteScript(cx: *mut JSContext, script: HandleScript, rval: MutableHandleValue) -> bool);
wrap!(pub fn JS_ExecuteScript1(cx: *mut JSContext, script: HandleScript) -> bool);
wrap!(pub fn JS_ExecuteScript2(cx: *mut JSContext, scopeChain: *mut AutoObjectVector, script: HandleScript, rval: MutableHandleValue) -> bool);
wrap!(pub fn JS_ExecuteScript3(cx: *mut JSContext, scopeChain: *mut AutoObjectVector, script: HandleScript) -> bool);
wrap!(pub fn CloneAndExecuteScript(cx: *mut JSContext, script: Handle<*mut JSScript>) -> bool);
wrap!(pub fn Evaluate(cx: *mut JSContext, options: *const ReadOnlyCompileOptions, srcBuf: *mut SourceBufferHolder, rval: MutableHandleValue) -> bool);
wrap!(pub fn Evaluate1(cx: *mut JSContext, scopeChain: *mut AutoObjectVector, options: *const ReadOnlyCompileOptions, srcBuf: *mut SourceBufferHolder, rval: MutableHandleValue) -> bool);
wrap!(pub fn Evaluate2(cx: *mut JSContext, options: *const ReadOnlyCompileOptions, chars: *const ::std::os::raw::c_ushort, length: usize, rval: MutableHandleValue) -> bool);
wrap!(pub fn Evaluate3(cx: *mut JSContext, scopeChain: *mut AutoObjectVector, options: *const ReadOnlyCompileOptions, chars: *const ::std::os::raw::c_ushort, length: usize, rval: MutableHandleValue) -> bool);
wrap!(pub fn Evaluate4(cx: *mut JSContext, options: *const ReadOnlyCompileOptions, bytes: *const ::std::os::raw::c_char, length: usize, rval: MutableHandleValue) -> bool);
wrap!(pub fn Evaluate5(cx: *mut JSContext, options: *const ReadOnlyCompileOptions, filename: *const ::std::os::raw::c_char, rval: MutableHandleValue) -> bool);
wrap!(pub fn SetModuleResolveHook(cx: *mut JSContext, func: HandleFunction));
wrap!(pub fn CompileModule(cx: *mut JSContext, options: *const ReadOnlyCompileOptions, srcBuf: *mut SourceBufferHolder, moduleRecord: MutableHandleObject) -> bool);
wrap!(pub fn ModuleDeclarationInstantiation(cx: *mut JSContext, moduleRecord: HandleObject) -> bool);
wrap!(pub fn ModuleEvaluation(cx: *mut JSContext, moduleRecord: HandleObject) -> bool);
wrap!(pub fn GetRequestedModules(cx: *mut JSContext, moduleRecord: HandleObject) -> *mut JSObject);
wrap!(pub fn GetModuleScript(cx: *mut JSContext, moduleRecord: HandleObject) -> *mut JSScript);
wrap!(pub fn NewPromiseObject(cx: *mut JSContext, executor: HandleObject, proto: HandleObject) -> *mut JSObject);
wrap!(pub fn IsPromiseObject(obj: HandleObject) -> bool);
wrap!(pub fn GetPromiseState(promise: HandleObject) -> PromiseState);
wrap!(pub fn GetPromiseID(promise: HandleObject) -> u64);
wrap!(pub fn GetPromiseResult(promise: HandleObject) -> Value);
wrap!(pub fn GetPromiseAllocationSite(promise: HandleObject) -> *mut JSObject);
wrap!(pub fn GetPromiseResolutionSite(promise: HandleObject) -> *mut JSObject);
wrap!(pub fn CallOriginalPromiseResolve(cx: *mut JSContext, resolutionValue: HandleValue) -> *mut JSObject);
wrap!(pub fn CallOriginalPromiseReject(cx: *mut JSContext, rejectionValue: HandleValue) -> *mut JSObject);
wrap!(pub fn ResolvePromise(cx: *mut JSContext, promise: HandleObject, resolutionValue: HandleValue) -> bool);
wrap!(pub fn RejectPromise(cx: *mut JSContext, promise: HandleObject, rejectionValue: HandleValue) -> bool);
wrap!(pub fn CallOriginalPromiseThen(cx: *mut JSContext, promise: HandleObject, onResolve: HandleObject, onReject: HandleObject) -> *mut JSObject);
wrap!(pub fn AddPromiseReactions(cx: *mut JSContext, promise: HandleObject, onResolve: HandleObject, onReject: HandleObject) -> bool);
wrap!(pub fn JS_AtomizeAndPinJSString(cx: *mut JSContext, str: HandleString) -> *mut JSString);
wrap!(pub fn JS_NewDependentString(cx: *mut JSContext, str: HandleString, start: usize, length: usize) -> *mut JSString);
wrap!(pub fn JS_ConcatStrings(cx: *mut JSContext, left: HandleString, right: HandleString) -> *mut JSString);
wrap!(pub fn JS_EncodeStringToUTF8(cx: *mut JSContext, str: HandleString) -> *mut ::std::os::raw::c_char);
wrap!(pub fn NewAddonId(cx: *mut JSContext, str: HandleString) -> *mut JSAddonId);
wrap!(pub fn NewSymbol(cx: *mut JSContext, description: HandleString) -> *mut Symbol);
wrap!(pub fn GetSymbolFor(cx: *mut JSContext, key: HandleString) -> *mut Symbol);
wrap!(pub fn GetSymbolDescription(symbol: HandleSymbol) -> *mut JSString);
wrap!(pub fn GetSymbolCode(symbol: Handle<*mut Symbol>) -> SymbolCode);
wrap!(pub fn PropertySpecNameEqualsId(name: *const ::std::os::raw::c_char, id: HandleId) -> bool);
wrap!(pub fn JS_Stringify(cx: *mut JSContext, value: MutableHandleValue, replacer: HandleObject, space: HandleValue, callback: JSONWriteCallback, data: *mut ::std::os::raw::c_void) -> bool);
wrap!(pub fn ToJSONMaybeSafely(cx: *mut JSContext, input: HandleObject, callback: JSONWriteCallback, data: *mut ::std::os::raw::c_void) -> bool);
wrap!(pub fn JS_ParseJSON(cx: *mut JSContext, chars: *const ::std::os::raw::c_ushort, len: u32, vp: MutableHandleValue) -> bool);
wrap!(pub fn JS_ParseJSON1(cx: *mut JSContext, str: HandleString, vp: MutableHandleValue) -> bool);
wrap!(pub fn JS_ParseJSONWithReviver(cx: *mut JSContext, chars: *const ::std::os::raw::c_ushort, len: u32, reviver: HandleValue, vp: MutableHandleValue) -> bool);
wrap!(pub fn JS_ParseJSONWithReviver1(cx: *mut JSContext, str: HandleString, reviver: HandleValue, vp: MutableHandleValue) -> bool);
wrap!(pub fn CreateError(cx: *mut JSContext, type_: JSExnType, stack: HandleObject, fileName: HandleString, lineNumber: u32, columnNumber: u32, report: *mut JSErrorReport, message: HandleString, rval: MutableHandleValue) -> bool);
wrap!(pub fn GetWeakMapEntry(cx: *mut JSContext, mapObj: HandleObject, key: HandleObject, val: MutableHandleValue) -> bool);
wrap!(pub fn SetWeakMapEntry(cx: *mut JSContext, mapObj: HandleObject, key: HandleObject, val: HandleValue) -> bool);
wrap!(pub fn MapSize(cx: *mut JSContext, obj: HandleObject) -> u32);
wrap!(pub fn MapGet(cx: *mut JSContext, obj: HandleObject, key: HandleValue, rval: MutableHandleValue) -> bool);
wrap!(pub fn MapHas(cx: *mut JSContext, obj: HandleObject, key: HandleValue, rval: *mut bool) -> bool);
wrap!(pub fn MapSet(cx: *mut JSContext, obj: HandleObject, key: HandleValue, val: HandleValue) -> bool);
wrap!(pub fn MapDelete(cx: *mut JSContext, obj: HandleObject, key: HandleValue, rval: *mut bool) -> bool);
wrap!(pub fn MapClear(cx: *mut JSContext, obj: HandleObject) -> bool);
wrap!(pub fn MapKeys(cx: *mut JSContext, obj: HandleObject, rval: MutableHandleValue) -> bool);
wrap!(pub fn MapValues(cx: *mut JSContext, obj: HandleObject, rval: MutableHandleValue) -> bool);
wrap!(pub fn MapEntries(cx: *mut JSContext, obj: HandleObject, rval: MutableHandleValue) -> bool);
wrap!(pub fn MapForEach(cx: *mut JSContext, obj: HandleObject, callbackFn: HandleValue, thisVal: HandleValue) -> bool);
wrap!(pub fn SetSize(cx: *mut JSContext, obj: HandleObject) -> u32);
wrap!(pub fn SetHas(cx: *mut JSContext, obj: HandleObject, key: HandleValue, rval: *mut bool) -> bool);
wrap!(pub fn SetDelete(cx: *mut JSContext, obj: HandleObject, key: HandleValue, rval: *mut bool) -> bool);
wrap!(pub fn SetAdd(cx: *mut JSContext, obj: HandleObject, key: HandleValue) -> bool);
wrap!(pub fn SetClear(cx: *mut JSContext, obj: HandleObject) -> bool);
wrap!(pub fn SetKeys(cx: *mut JSContext, obj: HandleObject, rval: MutableHandleValue) -> bool);
wrap!(pub fn SetValues(cx: *mut JSContext, obj: HandleObject, rval: MutableHandleValue) -> bool);
wrap!(pub fn SetEntries(cx: *mut JSContext, obj: HandleObject, rval: MutableHandleValue) -> bool);
wrap!(pub fn SetForEach(cx: *mut JSContext, obj: HandleObject, callbackFn: HandleValue, thisVal: HandleValue) -> bool);
wrap!(pub fn JS_ObjectIsDate(cx: *mut JSContext, obj: HandleObject, isDate: *mut bool) -> bool);
wrap!(pub fn JS_SetRegExpInput(cx: *mut JSContext, obj: HandleObject, input: HandleString) -> bool);
wrap!(pub fn JS_ClearRegExpStatics(cx: *mut JSContext, obj: HandleObject) -> bool);
wrap!(pub fn JS_ExecuteRegExp(cx: *mut JSContext, obj: HandleObject, reobj: HandleObject, chars: *mut ::std::os::raw::c_ushort, length: usize, indexp: *mut usize, test: bool, rval: MutableHandleValue) -> bool);
wrap!(pub fn JS_ExecuteRegExpNoStatics(cx: *mut JSContext, reobj: HandleObject, chars: *mut ::std::os::raw::c_ushort, length: usize, indexp: *mut usize, test: bool, rval: MutableHandleValue) -> bool);
wrap!(pub fn JS_ObjectIsRegExp(cx: *mut JSContext, obj: HandleObject, isRegExp: *mut bool) -> bool);
wrap!(pub fn JS_GetRegExpFlags(cx: *mut JSContext, obj: HandleObject) -> ::std::os::raw::c_uint);
wrap!(pub fn JS_GetRegExpSource(cx: *mut JSContext, obj: HandleObject) -> *mut JSString);
wrap!(pub fn JS_GetPendingException(cx: *mut JSContext, vp: MutableHandleValue) -> bool);
wrap!(pub fn JS_SetPendingException(cx: *mut JSContext, v: HandleValue));
wrap!(pub fn JS_ErrorFromException(cx: *mut JSContext, obj: HandleObject) -> *mut JSErrorReport);
wrap!(pub fn ExceptionStackOrNull(obj: HandleObject) -> *mut JSObject);
wrap!(pub fn JS_IndexToId(cx: *mut JSContext, index: u32, arg1: MutableHandleId) -> bool);
wrap!(pub fn JS_CharsToId(cx: *mut JSContext, chars: TwoByteChars, arg1: MutableHandleId) -> bool);
wrap!(pub fn JS_IsIdentifier(cx: *mut JSContext, str: HandleString, isIdentifier: *mut bool) -> bool);
wrap!(pub fn JS_EncodeScript(cx: *mut JSContext, script: HandleScript, lengthp: *mut u32) -> *mut ::std::os::raw::c_void);
wrap!(pub fn JS_EncodeInterpretedFunction(cx: *mut JSContext, funobj: HandleObject, lengthp: *mut u32) -> *mut ::std::os::raw::c_void);
wrap!(pub fn CaptureCurrentStack(cx: *mut JSContext, stackp: MutableHandleObject, maxFrameCount: ::std::os::raw::c_uint) -> bool);
wrap!(pub fn CopyAsyncStack(cx: *mut JSContext, asyncStack: HandleObject, asyncCause: HandleString, stackp: MutableHandleObject, maxFrameCount: ::std::os::raw::c_uint) -> bool);
wrap!(pub fn GetSavedFrameSource(cx: *mut JSContext, savedFrame: HandleObject, sourcep: MutableHandleString, selfHosted: SavedFrameSelfHosted) -> SavedFrameResult);
wrap!(pub fn GetSavedFrameLine(cx: *mut JSContext, savedFrame: HandleObject, linep: *mut u32, selfHosted: SavedFrameSelfHosted) -> SavedFrameResult);
wrap!(pub fn GetSavedFrameColumn(cx: *mut JSContext, savedFrame: HandleObject, columnp: *mut u32, selfHosted: SavedFrameSelfHosted) -> SavedFrameResult);
wrap!(pub fn GetSavedFrameFunctionDisplayName(cx: *mut JSContext, savedFrame: HandleObject, namep: MutableHandleString, selfHosted: SavedFrameSelfHosted) -> SavedFrameResult);
wrap!(pub fn GetSavedFrameAsyncCause(cx: *mut JSContext, savedFrame: HandleObject, asyncCausep: MutableHandleString, selfHosted: SavedFrameSelfHosted) -> SavedFrameResult);
wrap!(pub fn GetSavedFrameAsyncParent(cx: *mut JSContext, savedFrame: HandleObject, asyncParentp: MutableHandleObject, selfHosted: SavedFrameSelfHosted) -> SavedFrameResult);
wrap!(pub fn GetSavedFrameParent(cx: *mut JSContext, savedFrame: HandleObject, parentp: MutableHandleObject, selfHosted: SavedFrameSelfHosted) -> SavedFrameResult);
wrap!(pub fn BuildStackString(cx: *mut JSContext, stack: HandleObject, stringp: MutableHandleString, indent: usize) -> bool);
wrap!(pub fn JS_FindCompilationScope(cx: *mut JSContext, obj: HandleObject) -> *mut JSObject);
wrap!(pub fn JS_SplicePrototype(cx: *mut JSContext, obj: HandleObject, proto: HandleObject) -> bool);
wrap!(pub fn JS_NewObjectWithUniqueType(cx: *mut JSContext, clasp: *const JSClass, proto: HandleObject) -> *mut JSObject);
wrap!(pub fn JS_NewObjectWithoutMetadata(cx: *mut JSContext, clasp: *const JSClass, proto: HandleObject) -> *mut JSObject);
wrap!(pub fn JS_ObjectCountDynamicSlots(obj: HandleObject) -> u32);
wrap!(pub fn JS_NondeterministicGetWeakMapKeys(cx: *mut JSContext, obj: HandleObject, ret: MutableHandleObject) -> bool);
wrap!(pub fn JS_NondeterministicGetWeakSetKeys(cx: *mut JSContext, obj: HandleObject, ret: MutableHandleObject) -> bool);
wrap!(pub fn JS_CloneObject(cx: *mut JSContext, obj: HandleObject, proto: HandleObject) -> *mut JSObject);
wrap!(pub fn JS_InitializePropertiesFromCompatibleNativeObject(cx: *mut JSContext, dst: HandleObject, src: HandleObject) -> bool);
wrap!(pub fn JS_BasicObjectToString(cx: *mut JSContext, obj: HandleObject) -> *mut JSString);
wrap!(pub fn GetBuiltinClass(cx: *mut JSContext, obj: HandleObject, cls: *mut ESClass) -> bool);
wrap!(pub fn ObjectClassName(cx: *mut JSContext, obj: HandleObject) -> *const ::std::os::raw::c_char);
wrap!(pub fn ForceLexicalInitialization(cx: *mut JSContext, obj: HandleObject) -> bool);
wrap!(pub fn JS_CopyPropertiesFrom(cx: *mut JSContext, target: HandleObject, obj: HandleObject) -> bool);
wrap!(pub fn JS_CopyPropertyFrom(cx: *mut JSContext, id: HandleId, target: HandleObject, obj: HandleObject, copyBehavior: PropertyCopyBehavior) -> bool);
wrap!(pub fn JS_WrapPropertyDescriptor(cx: *mut JSContext, desc: MutableHandle<PropertyDescriptor>) -> bool);
wrap!(pub fn JS_DefineFunctionsWithHelp(cx: *mut JSContext, obj: HandleObject, fs: *const JSFunctionSpecWithHelp) -> bool);
wrap!(pub fn proxy_LookupProperty(cx: *mut JSContext, obj: HandleObject, id: HandleId, objp: MutableHandleObject, propp: MutableHandle<*mut Shape>) -> bool);
wrap!(pub fn proxy_DefineProperty(cx: *mut JSContext, obj: HandleObject, id: HandleId, desc: Handle<PropertyDescriptor>, result: *mut ObjectOpResult) -> bool);
wrap!(pub fn proxy_HasProperty(cx: *mut JSContext, obj: HandleObject, id: HandleId, foundp: *mut bool) -> bool);
wrap!(pub fn proxy_GetProperty(cx: *mut JSContext, obj: HandleObject, receiver: HandleValue, id: HandleId, vp: MutableHandleValue) -> bool);
wrap!(pub fn proxy_SetProperty(cx: *mut JSContext, obj: HandleObject, id: HandleId, bp: HandleValue, receiver: HandleValue, result: *mut ObjectOpResult) -> bool);
wrap!(pub fn proxy_GetOwnPropertyDescriptor(cx: *mut JSContext, obj: HandleObject, id: HandleId, desc: MutableHandle<PropertyDescriptor>) -> bool);
wrap!(pub fn proxy_DeleteProperty(cx: *mut JSContext, obj: HandleObject, id: HandleId, result: *mut ObjectOpResult) -> bool);
wrap!(pub fn proxy_Convert(cx: *mut JSContext, proxy: HandleObject, hint: JSType, vp: MutableHandleValue) -> bool);
wrap!(pub fn proxy_HasInstance(cx: *mut JSContext, proxy: HandleObject, v: MutableHandleValue, bp: *mut bool) -> bool);
wrap!(pub fn proxy_Watch(cx: *mut JSContext, obj: HandleObject, id: HandleId, callable: HandleObject) -> bool);
wrap!(pub fn proxy_Unwatch(cx: *mut JSContext, obj: HandleObject, id: HandleId) -> bool);
wrap!(pub fn proxy_GetElements(cx: *mut JSContext, proxy: HandleObject, begin: u32, end: u32, adder: *mut ElementAdder) -> bool);
wrap!(pub fn proxy_FunToString(cx: *mut JSContext, proxy: HandleObject, indent: ::std::os::raw::c_uint) -> *mut JSString);
wrap!(pub fn GetObjectProto(cx: *mut JSContext, obj: HandleObject, proto: MutableHandleObject) -> bool);
wrap!(pub fn GetOriginalEval(cx: *mut JSContext, scope: HandleObject, eval: MutableHandleObject) -> bool);
wrap!(pub fn GetPropertyKeys(cx: *mut JSContext, obj: HandleObject, flags: ::std::os::raw::c_uint, props: *mut AutoIdVector) -> bool);
wrap!(pub fn RegExpToSharedNonInline(cx: *mut JSContext, regexp: HandleObject, shared: *mut RegExpGuard) -> bool);
wrap!(pub fn DateIsValid(cx: *mut JSContext, obj: HandleObject, isValid: *mut bool) -> bool);
wrap!(pub fn DateGetMsecSinceEpoch(cx: *mut JSContext, obj: HandleObject, msecSinceEpoch: *mut f64) -> bool);
wrap!(pub fn JS_NewInt8ArrayFromArray(cx: *mut JSContext, array: HandleObject) -> *mut JSObject);
wrap!(pub fn JS_NewUint8ArrayFromArray(cx: *mut JSContext, array: HandleObject) -> *mut JSObject);
wrap!(pub fn JS_NewUint8ClampedArrayFromArray(cx: *mut JSContext, array: HandleObject) -> *mut JSObject);
wrap!(pub fn JS_NewInt16ArrayFromArray(cx: *mut JSContext, array: HandleObject) -> *mut JSObject);
wrap!(pub fn JS_NewUint16ArrayFromArray(cx: *mut JSContext, array: HandleObject) -> *mut JSObject);
wrap!(pub fn JS_NewInt32ArrayFromArray(cx: *mut JSContext, array: HandleObject) -> *mut JSObject);
wrap!(pub fn JS_NewUint32ArrayFromArray(cx: *mut JSContext, array: HandleObject) -> *mut JSObject);
wrap!(pub fn JS_NewFloat32ArrayFromArray(cx: *mut JSContext, array: HandleObject) -> *mut JSObject);
wrap!(pub fn JS_NewFloat64ArrayFromArray(cx: *mut JSContext, array: HandleObject) -> *mut JSObject);
wrap!(pub fn JS_NewInt8ArrayWithBuffer(cx: *mut JSContext, arrayBuffer: HandleObject, byteOffset: u32, length: i32) -> *mut JSObject);
wrap!(pub fn JS_NewUint8ArrayWithBuffer(cx: *mut JSContext, arrayBuffer: HandleObject, byteOffset: u32, length: i32) -> *mut JSObject);
wrap!(pub fn JS_NewUint8ClampedArrayWithBuffer(cx: *mut JSContext, arrayBuffer: HandleObject, byteOffset: u32, length: i32) -> *mut JSObject);
wrap!(pub fn JS_NewInt16ArrayWithBuffer(cx: *mut JSContext, arrayBuffer: HandleObject, byteOffset: u32, length: i32) -> *mut JSObject);
wrap!(pub fn JS_NewUint16ArrayWithBuffer(cx: *mut JSContext, arrayBuffer: HandleObject, byteOffset: u32, length: i32) -> *mut JSObject);
wrap!(pub fn JS_NewInt32ArrayWithBuffer(cx: *mut JSContext, arrayBuffer: HandleObject, byteOffset: u32, length: i32) -> *mut JSObject);
wrap!(pub fn JS_NewUint32ArrayWithBuffer(cx: *mut JSContext, arrayBuffer: HandleObject, byteOffset: u32, length: i32) -> *mut JSObject);
wrap!(pub fn JS_NewFloat32ArrayWithBuffer(cx: *mut JSContext, arrayBuffer: HandleObject, byteOffset: u32, length: i32) -> *mut JSObject);
wrap!(pub fn JS_NewFloat64ArrayWithBuffer(cx: *mut JSContext, arrayBuffer: HandleObject, byteOffset: u32, length: i32) -> *mut JSObject);
wrap!(pub fn JS_GetArrayBufferViewBuffer(cx: *mut JSContext, obj: HandleObject, isSharedMemory: *mut bool) -> *mut JSObject);
wrap!(pub fn JS_DetachArrayBuffer(cx: *mut JSContext, obj: HandleObject, changeData: DetachDataDisposition) -> bool);
wrap!(pub fn JS_NewDataView(cx: *mut JSContext, arrayBuffer: HandleObject, byteOffset: u32, byteLength: i32) -> *mut JSObject);
wrap!(pub fn WatchGuts(cx: *mut JSContext, obj: HandleObject, id: HandleId, callable: HandleObject) -> bool);
wrap!(pub fn UnwatchGuts(cx: *mut JSContext, obj: HandleObject, id: HandleId) -> bool);
wrap!(pub fn PrepareScriptEnvironmentAndInvoke(cx: *mut JSContext, scope: HandleObject, closure: *mut ScriptEnvironmentPreparer_Closure));
wrap!(pub fn GetElementsWithAdder(cx: *mut JSContext, obj: HandleObject, receiver: HandleObject, begin: u32, end: u32, adder: *mut ElementAdder) -> bool);
wrap!(pub fn SetPropertyIgnoringNamedGetter(cx: *mut JSContext, obj: HandleObject, id: HandleId, v: HandleValue, receiver: HandleValue, ownDesc: Handle<PropertyDescriptor>, result: *mut ObjectOpResult) -> bool);
wrap!(pub fn ReportErrorWithId(cx: *mut JSContext, msg: *const ::std::os::raw::c_char, id: HandleId));
wrap!(pub fn ExecuteInGlobalAndReturnScope(cx: *mut JSContext, obj: HandleObject, script: HandleScript, scope: MutableHandleObject) -> bool);
wrap!(pub fn GetFirstSubsumedSavedFrame(cx: *mut JSContext, savedFrame: HandleObject, selfHosted: SavedFrameSelfHosted) -> *mut JSObject);
wrap!(pub fn ReportIsNotFunction(cx: *mut JSContext, v: HandleValue) -> bool);
wrap!(pub fn SetWindowProxy(cx: *mut JSContext, global: HandleObject, windowProxy: HandleObject));
wrap!(pub fn ToBooleanSlow(v: HandleValue) -> bool);
wrap!(pub fn ToInt8Slow(cx: *mut JSContext, v: HandleValue, out: *mut i8) -> bool);
wrap!(pub fn ToUint8Slow(cx: *mut JSContext, v: HandleValue, out: *mut u8) -> bool);
wrap!(pub fn ToInt16Slow(cx: *mut JSContext, v: HandleValue, out: *mut i16) -> bool);
wrap!(pub fn ToInt32Slow(cx: *mut JSContext, v: HandleValue, out: *mut i32) -> bool);
wrap!(pub fn ToUint32Slow(cx: *mut JSContext, v: HandleValue, out: *mut u32) -> bool);
wrap!(pub fn ToUint16Slow(cx: *mut JSContext, v: HandleValue, out: *mut u16) -> bool);
wrap!(pub fn ToInt64Slow(cx: *mut JSContext, v: HandleValue, out: *mut i64) -> bool);
wrap!(pub fn ToUint64Slow(cx: *mut JSContext, v: HandleValue, out: *mut u64) -> bool);
wrap!(pub fn ToStringSlow(cx: *mut JSContext, v: HandleValue) -> *mut JSString);
wrap!(pub fn ToObjectSlow(cx: *mut JSContext, v: HandleValue, reportScanStack: bool) -> *mut JSObject);
wrap!(pub fn OrdinaryToPrimitive(cx: *mut JSContext, obj: HandleObject, type_: JSType, vp: MutableHandleValue) -> bool);
wrap!(pub fn AddSizeOfTab(rt: *mut JSRuntime, obj: HandleObject, mallocSizeOf: MallocSizeOf, opv: *mut ObjectPrivateVisitor, sizes: *mut TabSizes) -> bool);
